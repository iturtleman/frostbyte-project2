using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace Frostbyte
{
    /// <summary>
    /// Wraper class for our dictionary that allows us to most efficiently obtain data from the dictionary
    /// Shared with The Level Editor
    /// </summary>
    public partial class TileList<T> where T : LevelObject, new()
    {
        /// <summary>
        /// Dict of the form [y,x]=Tile
        /// </summary>
        List<List<T>> mTiles = new List<List<T>>();

        /// <summary>
        /// All data that the level file contains in order from the file (for saving again)
        /// </summary>
        List<LevelObject> LevelParts = new List<LevelObject>();

        public Tuple<List<LevelObject>, List<List<T>>> Data
        {
            get
            {
                return new Tuple<List<LevelObject>, List<List<T>>>(LevelParts, mTiles);
            }
        }

        Index2D cache_key = new Index2D(-1, -1);
        T cache_value;

        internal TileList()
        {

        }

        #region Adds
        /// <summary>
        /// Adds a Tile to the tile map but not list of objects
        /// </summary>
        /// <param name="t">The tile to add</param>
        /// <param name="x">The X grid location</param>
        /// <param name="y">The Y gird location</param>
        /// <returns></returns>
        internal bool Add(T t, int x, int y)
        {
            //fills grid
            while (mTiles.Count < y + 1)
            {
                mTiles.Add(new List<T>());
            }
            foreach (var row in mTiles)
                while (row.Count < x + 1)
                {
                    row.Add(new T());
                }

            mTiles[y][x] = t;
            return true;
        }

        /// <summary>
        /// Adds the Room to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Room to add</param>
        /// <returns>Success</returns>
        internal bool Add(Room r)
        {
            LevelParts.Add(r);
            //add tiles to the list
            return true;
        }

        /// <summary>
        /// Adds the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Walls to add</param>
        /// <param name="Tiles">List of tiles generated by the borderawlls</param>
        /// <returns>Success</returns>
        private bool Add(BorderWalls w)
        {
            try
            {
                LevelParts.Add(w);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Adds the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <returns>Success</returns>
        internal bool Add(Wall w)
        {
            LevelParts.Add(w);
            return true;
        }

        /// <summary>
        /// Adds the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <returns>Success</returns>
        internal bool Add(Floor f)
        {
            LevelParts.Add(f);
            return true;
        }

        /// <summary>
        /// Adds a FrostByte.Tile to the grid and to ObjectList
        /// </summary>
        /// <param name="r">Room to add</param>
        /// <returns>Success</returns>
        internal bool Add(T r)
        {
            if (r as LevelObject != null)
            {
                //determine what it is
                if (r as Tile != null)
                {
                    Tile t = r as Tile;
                    Add(r, r.GridCell.X, r.GridCell.Y);
                    LevelParts.Add(t);
                    return true;
                }
            }
            //it's a level editor tile
            return false;
        }

        /// <summary>
        /// Determines what an object is and adds it to the level
        /// </summary>
        /// <param name="obj">Object we want to split and add</param>
        internal List<T> Add(LevelPart obj)
        {
            List<T> tiles = new List<T>();
            //deterime what it is
            if (obj.GetType() == typeof(Room))
            {
                Room r = obj as Room;
                if (Add(r))
                {
                    //we're going to be getting them a lot otherwise
                    Index2D start = new Index2D(Math.Min(r.StartCell.X, r.EndCell.X), Math.Min(r.StartCell.Y, r.EndCell.Y));
                    Index2D end = new Index2D(Math.Max(r.StartCell.X, r.EndCell.X), Math.Max(r.StartCell.Y, r.EndCell.Y));
                    List<T> t;
                    Add(new BorderWalls(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Add(t[i]);
                    }

                    t = new List<T>();
                    Add(new Floor(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Add(t[i]);
                    }

                }
            }
            else if (obj.GetType() == typeof(BorderWalls))
            {
                List<T> t;
                Add(obj as BorderWalls, out t);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            else if (obj.GetType() == typeof(Wall))
            {
                List<T> t;
                Add(obj as Wall, out t);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            else if (obj.GetType() == typeof(Floor))
            {
                List<T> t;
                Add(obj as Floor, out t);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            return tiles;
        }

        #region Magic Adds

        /// <summary>
        /// Adds the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Walls to add</param>
        /// <param name="Tiles">Listof tiles generated by the borderawlls</param>
        /// <param name="dontAdd">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        private void Add(BorderWalls w, out List<T> Tiles, bool dontAdd = false)
        {
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));

            List<T> tiles = new List<T>();
            if (dontAdd || Add(w))
            {
                List<T> ts;
                //place Left wall
                Add(new Wall(new Index2D(start.X, start.Y + 1), new Index2D(start.X, end.Y - 1), Orientations.Right, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place right wall
                Add(new Wall(new Index2D(end.X, start.Y + 1), new Index2D(end.X, end.Y - 1), Orientations.Left, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place Top wall
                Add(new Wall(new Index2D(start.X + 1, start.Y), new Index2D(end.X - 1, start.Y), Orientations.Down, TileTypes.Wall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place Top wall
                Add(new Wall(new Index2D(start.X + 1, end.Y), new Index2D(end.X - 1, end.Y), Orientations.Down, TileTypes.Bottom, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place corners
                //TL
                T t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Right,
                    GridCell = start,
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);

                //TR
                t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Down,
                    GridCell = new Index2D(end.X, start.Y)
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);

                //BL
                t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Up_Right,
                    GridCell = new Index2D(start.X, end.Y)
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);

                //BR
                t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Up,
                    GridCell = new Index2D(end.X, end.Y)
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);
            }
            Tiles = tiles;
        }

        /// <summary>
        /// Adds the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <param name="dontAdd">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Add(Wall w, out List<T> Tiles, bool dontAdd = false)
        {
            List<T> tiles = new List<T>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));
            Index2D diff = end - start;
            if (dontAdd || Add(w))
            {
                //add tiles to the list
                if (w.Type == TileTypes.SideWall || diff.MagX < diff.MagY)
                {
                    //place on side

                    //Rt wall
                    if (w.Orientation == Orientations.Left || diff.X < 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Add Right
                            T t = new T()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Left,
                                GridCell = new Index2D(end.X, y)
                            };
                            tiles.Add(t);
                            Add(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                    //left wall
                    else if (w.Orientation == Orientations.Right || diff.X > 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Add left
                            T t = new T()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Right,
                                GridCell = new Index2D(start.X, y)
                            };
                            tiles.Add(t);
                            Add(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                }
                else if (w.Type == TileTypes.Wall || (diff.MagX > diff.MagY && w.Type == TileTypes.Wall))
                {
                    //Place top
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Add Top
                        T t = new T()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y >= 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, start.Y)
                        };
                        tiles.Add(t);
                        Add(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
                else if (w.Type == TileTypes.Bottom || (diff.MagX > diff.MagY && w.Type == TileTypes.Bottom))
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Add Bottom
                        T t = new T()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y < 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, end.Y)
                        };
                        tiles.Add(t);
                        Add(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }

        /// <summary>
        /// Adds the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <param name="dontAdd">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Add(Floor f, out List<T> Tiles, bool dontAdd = false)
        {
            List<T> tiles = new List<T>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(f.StartCell.X, f.EndCell.X), Math.Min(f.StartCell.Y, f.EndCell.Y));
            Index2D end = new Index2D(Math.Max(f.StartCell.X, f.EndCell.X), Math.Max(f.StartCell.Y, f.EndCell.Y));
            if (dontAdd || Add(f))
            {
                //add tiles to the list
                //place floor
                for (int y = start.Y; y <= end.Y; y++)
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Add Bottom
                        T tile = new T()
                        {
                            Type = f.Type,
                            FloorType = f.FloorType,
                            Theme = f.Theme,
                            Traversable = f.Traversable,
                            Orientation = Orientations.Down,
                            GridCell = new Index2D(x, y)
                        };
                        tiles.Add(tile);
                        Add(tile, tile.GridCell.X, tile.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }
        #endregion Magic Adds
        #endregion Adds

        #region RemoveItems
        public bool Remove(T elem)
        {
            Tile t = elem as Tile;
            if (t != null)
            {
                mTiles[t.GridCell.Y][t.GridCell.X] = new T();
                LevelParts.Remove(t);
                return true;
            }
            return false;
        }

        public bool Remove(T elem, int x, int y)
        {
            mTiles[y][x] = new T();
            return true;
        }

        /// <summary>
        /// Removes the Room to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Room to add</param>
        /// <returns>Success</returns>
        internal bool Remove(Room r)
        {
            LevelParts.Remove(r);
            //add tiles to the list
            return true;
        }

        /// <summary>
        /// Removes the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Walls to add</param>
        /// <param name="Tiles">List of tiles generated by the borderawlls</param>
        /// <returns>Success</returns>
        private bool Remove(BorderWalls w)
        {
            try
            {
                LevelParts.Remove(w);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Removes the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <returns>Success</returns>
        internal bool Remove(Wall w)
        {
            LevelParts.Remove(w);
            return true;
        }

        /// <summary>
        /// Removes the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <returns>Success</returns>
        internal bool Remove(Floor f)
        {
            LevelParts.Remove(f);
            return true;
        }

        /// <summary>
        /// Determines what an object is and adds it to the level
        /// </summary>
        /// <param name="obj">Object we want to split and add</param>
        internal List<T> Remove(LevelPart obj)
        {
            List<T> tiles = new List<T>();
            //deterime what it is
            if (obj.GetType() == typeof(Room))
            {
                Room r = obj as Room;
                if (Remove(r))
                {
                    //we're going to be getting them a lot otherwise
                    Index2D start = new Index2D(Math.Min(r.StartCell.X, r.EndCell.X), Math.Min(r.StartCell.Y, r.EndCell.Y));
                    Index2D end = new Index2D(Math.Max(r.StartCell.X, r.EndCell.X), Math.Max(r.StartCell.Y, r.EndCell.Y));
                    List<T> t;
                    Remove(new BorderWalls(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Remove(t[i]);
                    }

                    t = new List<T>();
                    Remove(new Floor(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Remove(t[i]);
                    }

                }
            }
            else if (obj.GetType() == typeof(BorderWalls))
            {
                List<T> t;
                Remove(obj as BorderWalls, out t);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Remove(t[i]);
                }
            }
            else if (obj.GetType() == typeof(Wall))
            {
                List<T> t;
                Remove(obj as Wall, out t);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Remove(t[i]);
                }
            }
            else if (obj.GetType() == typeof(Floor))
            {
                List<T> t;
                Remove(obj as Floor, out t);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Remove(t[i]);
                }
            }
            return tiles;
        }

        #region Magic Removes

        /// <summary>
        /// Removes the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Walls to add</param>
        /// <param name="Tiles">Listof tiles generated by the borderawlls</param>
        /// <param name="dontRemove">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        private void Remove(BorderWalls w, out List<T> Tiles, bool dontRemove = false)
        {
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));

            List<T> tiles = new List<T>();
            if (dontRemove || Remove(w))
            {
                List<T> ts;
                //place Left wall
                Remove(new Wall(new Index2D(start.X, start.Y + 1), new Index2D(start.X, end.Y - 1), Orientations.Right, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Remove(ts[i]);
                }

                //place right wall
                Remove(new Wall(new Index2D(end.X, start.Y + 1), new Index2D(end.X, end.Y - 1), Orientations.Left, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Remove(ts[i]);
                }

                //place Top wall
                Remove(new Wall(new Index2D(start.X + 1, start.Y), new Index2D(end.X - 1, start.Y), Orientations.Down, TileTypes.Wall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Remove(ts[i]);
                }

                //place Top wall
                Remove(new Wall(new Index2D(start.X + 1, end.Y), new Index2D(end.X - 1, end.Y), Orientations.Down, TileTypes.Bottom, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Remove(ts[i]);
                }

                //place corners
                //TL
                T t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Right,
                    GridCell = start,
                };
                tiles.Remove(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);

                //TR
                t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Down,
                    GridCell = new Index2D(end.X, start.Y)
                };
                tiles.Remove(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);

                //BL
                t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Up_Right,
                    GridCell = new Index2D(start.X, end.Y)
                };
                tiles.Remove(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);

                //BR
                t = new T()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Up,
                    GridCell = new Index2D(end.X, end.Y)
                };
                tiles.Remove(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);
            }
            Tiles = tiles;
        }

        /// <summary>
        /// Removes the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <param name="dontRemove">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Remove(Wall w, out List<T> Tiles, bool dontRemove = false)
        {
            List<T> tiles = new List<T>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));
            Index2D diff = end - start;
            if (dontRemove || Remove(w))
            {
                //add tiles to the list
                if (w.Type == TileTypes.SideWall || diff.MagX < diff.MagY)
                {
                    //place on side

                    //Rt wall
                    if (w.Orientation == Orientations.Left || diff.X < 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Remove Right
                            T t = new T()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Left,
                                GridCell = new Index2D(end.X, y)
                            };
                            tiles.Remove(t);
                            Remove(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                    //left wall
                    else if (w.Orientation == Orientations.Right || diff.X > 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Remove left
                            T t = new T()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Right,
                                GridCell = new Index2D(start.X, y)
                            };
                            tiles.Remove(t);
                            Remove(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                }
                else if (w.Type == TileTypes.Wall || (diff.MagX > diff.MagY && w.Type == TileTypes.Wall))
                {
                    //Place top
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Remove Top
                        T t = new T()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y >= 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, start.Y)
                        };
                        tiles.Remove(t);
                        Remove(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
                else if (w.Type == TileTypes.Bottom || (diff.MagX > diff.MagY && w.Type == TileTypes.Bottom))
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Remove Bottom
                        T t = new T()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y < 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, end.Y)
                        };
                        tiles.Remove(t);
                        Remove(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }

        /// <summary>
        /// Removes the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <param name="dontRemove">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Remove(Floor f, out List<T> Tiles, bool dontRemove = false)
        {
            List<T> tiles = new List<T>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(f.StartCell.X, f.EndCell.X), Math.Min(f.StartCell.Y, f.EndCell.Y));
            Index2D end = new Index2D(Math.Max(f.StartCell.X, f.EndCell.X), Math.Max(f.StartCell.Y, f.EndCell.Y));
            if (dontRemove || Remove(f))
            {
                //add tiles to the list
                //place floor
                for (int y = start.Y; y <= end.Y; y++)
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Remove Bottom
                        T tile = new T()
                        {
                            Type = f.Type,
                            FloorType = f.FloorType,
                            Theme = f.Theme,
                            Traversable = f.Traversable,
                            Orientation = Orientations.Down,
                            GridCell = new Index2D(x, y)
                        };
                        tiles.Remove(tile);
                        Remove(tile, tile.GridCell.X, tile.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }
        #endregion Magic Removes
        #endregion RemoveItems

        internal bool TryGetValue(int x, int y, out T value)
        {
            if (cache_key.X == x && cache_key.Y == y)
            {
                value = cache_value;
                return true;
            }

            if (mTiles[y][x] != null)
            {
                value = mTiles[y][x];
                cache_key = new Index2D(x, y);
                cache_value = value;
                return true;
            }

            value = new T();
            return false;
        }

        internal void Clear()
        {
            mTiles.Clear();
        }

        /// <summary>
        /// Indexer into the list[]
        /// </summary>
        /// <param name="i">element</param>
        /// <returns>the list at that index</returns>
        public List<T> this[int i]
        {
            get
            {
                return mTiles[i];
            }
            set
            {
                mTiles[i] = value;
            }
        }

        public TileList<T> Duplicate()
        {
            return this.MemberwiseClone() as TileList<T>;
        }

        /// <summary>
        /// creates all the rooms, tiles, etc that would be needed to generate the level
        /// </summary>
        /// <returns></returns>
        public List<LevelObject> GenerateSaveObjects()
        {
            List<LevelObject> objs = new List<LevelObject>();
            TileList<T> copy = Duplicate();
            //remove from copy all the tiles that match our current objects
            foreach (LevelPart lo in LevelParts)
            {
                List<T> removed = copy.Remove(lo);
                foreach (T tile in removed)
                {
                    Index2D cell = tile.GridCell;
                    if (mTiles[cell.Y][cell.X] == tile)
                    {
                        copy.Remove(tile);
                    }
                }
            }
            int ycount = mTiles.Count;
            int xcount = mTiles[0].Count;
            for (int y = 0; y < ycount; y++)
            {
                for (int x = 0; x < xcount; x++)
                {
                    T tile = copy[y][x];
                    //this means it's a tile we care about
                    if (tile.Type != TileTypes.DEFAULT)
                    {
                        /// \todo complete this!!!!!
                    }
                }
            }

            return objs;
        }

        /// <summary>
        /// Saves the Document to the given tile
        /// </summary>
        /// <param name="filename">SaveFile name</param>
        /// <param name="doc">Document to save</param>
        public void Save(string filename, XDocument doc)
        {
            doc.Save(filename);
        }

        /// <summary>
        /// Generates the XDocument with all our data.
        /// </summary>
        /// <returns>XDocument form of the level</returns>
        public XDocument Serialize()
        {
            XDocument doc = new XDocument(new XElement("Level"));

            return doc;
        }

        /// <summary>
        /// Loads File
        /// </summary>
        /// <param name="filename">Name of the file to load</param>
        /// <returns>The object created</returns>
        public static TileList<T> Load(string filename)
        {
            return Parse(XDocument.Load(filename));
        }

        /// <summary>
        /// parses an xdocument and re
        /// </summary>
        /// <param name="doc"></param>
        /// <returns></returns>
        public static TileList<T> Parse(XDocument doc)
        {
            //load data
            TileList<T> tl = new TileList<T>();


            return tl;
        }
    }
}
